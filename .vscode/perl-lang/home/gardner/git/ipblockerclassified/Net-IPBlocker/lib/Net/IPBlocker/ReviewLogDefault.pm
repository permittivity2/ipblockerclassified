{"vars":[{"line":2,"kind":2,"definition":1,"name":"Net::IPBlocker::ReviewLogDefault"},{"containerName":"","name":"strict","kind":2,"line":4},{"line":5,"kind":2,"name":"warnings","containerName":""},{"containerName":"","kind":2,"line":6,"name":"Exporter"},{"kind":2,"line":7,"name":"IPv6","containerName":"Regexp"},{"containerName":"Log","kind":2,"line":8,"name":"Any"},{"name":"threads","line":9,"kind":2,"containerName":""},{"containerName":"Data","line":10,"kind":2,"name":"Dumper"},{"containerName":null,"name":"$Data","kind":13,"line":12},{"name":"Dumper","line":12,"kind":12,"containerName":"Sortkeys"},{"line":13,"kind":13,"name":"$Data","containerName":null},{"name":"Dumper","kind":12,"line":13,"containerName":"Indent"},{"line":15,"kind":13,"definition":"our","name":"@EXPORT_OK","containerName":"Net::IPBlocker::ReviewLogDefault"},{"kind":13,"definition":"my","name":"$logger","localvar":"my","line":17,"containerName":null},{"containerName":null,"name":"$log","line":17,"kind":13},{"kind":13,"containerName":null,"localvar":"my","definition":"my","name":"$REGEX_IPV4","line":18},{"line":19,"localvar":"my","definition":"my","name":"$REGEX_IPV6","containerName":null,"kind":13},{"line":52,"definition":"sub","name":"grep_regexps","children":[{"containerName":"grep_regexps","definition":"my","name":"$self","localvar":"my","line":53,"kind":13},{"kind":13,"line":53,"name":"$log","containerName":"grep_regexps"},{"kind":13,"line":54,"localvar":"my","definition":"my","name":"$TID","containerName":"grep_regexps"},{"kind":12,"line":54,"name":"tid","containerName":"grep_regexps"},{"containerName":"grep_regexps","kind":13,"line":55,"name":"$logger"},{"kind":12,"line":55,"name":"debug","containerName":"grep_regexps"},{"kind":13,"containerName":"grep_regexps","line":57,"definition":"my","name":"$matches","localvar":"my"},{"kind":13,"name":"@log_contents","definition":"my","localvar":"my","line":58,"containerName":"grep_regexps"},{"containerName":"grep_regexps","name":"$log","line":58,"kind":13}],"detail":"($self,$log)","containerName":"Net::IPBlocker::ReviewLogDefault","range":{"end":{"character":9999,"line":58},"start":{"character":0,"line":52}},"kind":12,"signature":{"parameters":[{"label":"$self"},{"label":"$log"}],"documentation":"# FILEPATH: Untitled-1\n\npackage Net::IPBlocker::ReviewLogDefault;\n\nuse strict;\nuse warnings;\nuse Exporter;\nuse Regexp::IPv6     qw($IPv6_re);\nuse Log::Any qw($log);  # Allegedly handles lots of different logging modules\nuse threads;\nuse Data::Dumper;\n\nlocal $Data::Dumper::Sortkeys = 1;\nlocal $Data::Dumper::Indent   = 1;\n\nour @EXPORT_OK = qw(grep_regexps);\n\nmy $logger = $log;\nmy $REGEX_IPV4 = q/\\b((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\\b/;\nmy $REGEX_IPV6      = q/\\b($IPv6_re)\\b/;\n\n=head1 NAME\n\nNet::IPBlocker::GrepRegexpsDefault - Default regular expressions for IP blocking\n\n=head1 SYNOPSIS\n\n    This works with the Net::IPBlocker module to provide a default sub for regular expressions for IP blocking.\n    This is alos a framework that could be used to create other modules that provide default regular expressions for \n    IP Blocking of particular types of files such as Apache logs, Postfix logs, Auth logs, etc.\n\n    The calling code will always pass in the log object and the log contents.\n\n=head1 DESCRIPTION\n\nThis module provides a default regular expression sub for IP blocking. \nThese regular expressions can be used with the L<Net::IPBlocker> module to match and block IP addresses.\n\n=head1 METHODS\n\n=head2 get_regexps\n\nReturns an array of default regular expressions for IP blocking.\n\n    my @regexps = Net::IPBlocker::GrepRegexpsDefault->get_regexps();\n\n Description:  Using the logobj, this greps against the log contents for matching lines and then gets the\n               IP address on each line.\n Requires:     $self, $log\n Returns:      Hash reference of IP addresses with count of how many times the IP address was found","label":"grep_regexps($self,$log)"}},{"line":54,"kind":12,"name":"threads"},{"name":"logcontents","kind":12,"line":58},{"kind":13,"line":60,"name":"@log_contents","containerName":null},{"containerName":null,"name":"$regex","definition":"my","localvar":"my","line":63,"kind":13},{"name":"%log","kind":13,"line":63,"containerName":null},{"line":63,"kind":12,"name":"regexpdeny"},{"kind":13,"containerName":null,"definition":"my","name":"$pattern","localvar":"my","line":64},{"line":64,"kind":13,"name":"%log","containerName":null},{"kind":12,"line":64,"name":"regexpdeny"},{"containerName":null,"line":64,"kind":13,"name":"$regex"},{"containerName":null,"name":"$logger","line":65,"kind":13},{"containerName":"Net::IPBlocker::ReviewLogDefault","name":"debug","kind":12,"line":65},{"kind":13,"localvar":"my","definition":"my","name":"@current_matches","line":67,"containerName":null},{"containerName":null,"name":"@log_contents","kind":13,"line":67},{"line":68,"kind":13,"name":"$logger","containerName":null},{"containerName":"Net::IPBlocker::ReviewLogDefault","name":"debug","line":68,"kind":12},{"kind":12,"line":68,"name":"Dumper"},{"containerName":null,"name":"@current_matches","kind":13,"line":68},{"containerName":null,"line":68,"kind":13,"name":"$logger"},{"name":"is_debug","line":68,"kind":12,"containerName":"Net::IPBlocker::ReviewLogDefault"},{"kind":13,"name":"$line","definition":"my","localvar":"my","line":70,"containerName":null},{"containerName":null,"name":"@current_matches","line":70,"kind":13},{"containerName":null,"line":71,"kind":13,"name":"$line"},{"containerName":null,"kind":13,"line":72,"name":"$logger"},{"containerName":"Net::IPBlocker::ReviewLogDefault","name":"debug","line":72,"kind":12},{"kind":13,"localvar":"my","definition":"my","name":"$ip_address","line":74,"containerName":null},{"containerName":null,"name":"$line","line":74,"kind":13},{"kind":13,"line":74,"name":"%line","containerName":null},{"containerName":null,"name":"%matches","line":75,"kind":13},{"containerName":null,"kind":13,"line":75,"name":"$ip_address"},{"kind":13,"line":76,"name":"$logger","containerName":null},{"containerName":"Net::IPBlocker::ReviewLogDefault","name":"debug","kind":12,"line":76},{"kind":13,"line":81,"name":"$logger","containerName":null},{"name":"debug","line":81,"kind":12,"containerName":"Net::IPBlocker::ReviewLogDefault"},{"line":81,"kind":12,"name":"Dumper"},{"containerName":null,"line":81,"kind":13,"name":"$matches"},{"containerName":null,"line":81,"kind":13,"name":"$logger"},{"containerName":"Net::IPBlocker::ReviewLogDefault","line":81,"kind":12,"name":"is_debug"},{"kind":13,"line":83,"name":"$log_msg","definition":"my","localvar":"my","containerName":null},{"line":84,"kind":13,"name":"$log_msg","containerName":null},{"line":84,"kind":13,"name":"$matches","containerName":null},{"line":85,"kind":13,"name":"$logger","containerName":null},{"containerName":"Net::IPBlocker::ReviewLogDefault","name":"info","kind":12,"line":85},{"line":85,"kind":13,"name":"$log_msg","containerName":null},{"name":"$matches","line":87,"kind":13,"containerName":null},{"kind":12,"range":{"start":{"line":104,"character":0},"end":{"line":109,"character":9999}},"signature":{"label":"test()","parameters":[],"documentation":"# FILEPATH: Untitled-1\n\npackage Net::IPBlocker::ReviewLogDefault;\n\nuse strict;\nuse warnings;\nuse Exporter;\nuse Regexp::IPv6     qw($IPv6_re);\nuse Log::Any qw($log);  # Allegedly handles lots of different logging modules\nuse threads;\nuse Data::Dumper;\n\nlocal $Data::Dumper::Sortkeys = 1;\nlocal $Data::Dumper::Indent   = 1;\n\nour @EXPORT_OK = qw(grep_regexps);\n\nmy $logger = $log;\nmy $REGEX_IPV4 = q/\\b((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\\b/;\nmy $REGEX_IPV6      = q/\\b($IPv6_re)\\b/;\n\n=head1 NAME\n\nNet::IPBlocker::GrepRegexpsDefault - Default regular expressions for IP blocking\n\n=head1 SYNOPSIS\n\n    This works with the Net::IPBlocker module to provide a default sub for regular expressions for IP blocking.\n    This is alos a framework that could be used to create other modules that provide default regular expressions for \n    IP Blocking of particular types of files such as Apache logs, Postfix logs, Auth logs, etc.\n\n    The calling code will always pass in the log object and the log contents.\n\n=head1 DESCRIPTION\n\nThis module provides a default regular expression sub for IP blocking. \nThese regular expressions can be used with the L<Net::IPBlocker> module to match and block IP addresses.\n\n=head1 METHODS\n\n=head2 get_regexps\n\nReturns an array of default regular expressions for IP blocking.\n\n    my @regexps = Net::IPBlocker::GrepRegexpsDefault->get_regexps();\n\n\n# Description:  Using the logobj, this greps against the log contents for matching lines and then gets the\n#               IP address on each line.\n# Requires:     $self, $log\n# Returns:      Hash reference of IP addresses with count of how many times the IP address was found\nsub grep_regexps {\n    my ( $self, $log ) = @_;\n    my $TID = \"TID: \" . threads->tid;\n    $logger->debug(\"$TID|In grep_regexps in \" . __PACKAGE__ . \" module.\");\n\n    my $matches      = {};\n    my @log_contents = @{ $log->{logcontents} };\n\n    return {} if ( !@log_contents );\n\n    # DO NOT SORT NUMERICALLY!  The info in the configs states the order is sorted alphabetically\n    foreach my $regex ( sort keys %{ $log->{regexpdeny} } ) {\n        my $pattern = $log->{regexpdeny}{$regex};\n        $logger->debug(\"$TID|Grep'ing for >>$pattern<< in $log->{file} from byte position $log->{seek}\");\n\n        my @current_matches = grep { /$pattern/ } @log_contents;\n        $logger->debug( \"$TID|Dumper of current matches: \" . Dumper(@current_matches) ) if $logger->is_debug();\n\n        foreach my $line (@current_matches) {\n            chomp($line);\n            $logger->debug(\"$TID|Checking >>$line<< for IP address\");\n\n            foreach my $ip_address ( $line =~ /$REGEX_IPV4/g, $line =~ /$REGEX_IPV6/g ) {\n                $matches->{$ip_address}++;\n                $logger->debug(\"$TID|Found IP address: $ip_address\");\n            }\n        } ## end foreach my $line (@current_matches)\n    } ## end foreach my $regex ( sort keys...)\n\n    $logger->debug( \"$TID|Dump of IP matches after all regex comparisons: \" . Dumper($matches) ) if $logger->is_debug();\n\n    my $log_msg = \"$TID|Matched IP addresses to be reviewed for potential blocking: \";\n    $log_msg .= join( \",\", keys %{$matches} );\n    $logger->info($log_msg);\n\n    return $matches;\n} ## end sub grep_regexps\n\n=head2 test\n\nThis is just a simple test sub.  It is not required but is nice to have for testing.\n\nThis sub is called after the module is successfully loaded as a sanity check.\n\nYou can put whatever you want into it but returning 1 (Perl truthy) will keep a warning from happening\n\n Description:  Just a test sub for a sanity check.  Not really required but nice to have for testing\n               My lessons learned:\n               1.  Make sure the last part of the package name actually matches the file name (without the pm)\n Returns:      1"},"definition":"sub","name":"test","line":104,"containerName":"Net::IPBlocker::ReviewLogDefault","detail":"()","children":[{"definition":"my","name":"$self","localvar":"my","line":105,"containerName":"test","kind":13},{"containerName":"test","line":106,"definition":"my","name":"$TID","localvar":"my","kind":13},{"name":"tid","line":106,"kind":12,"containerName":"test"},{"containerName":"test","name":"$logger","kind":13,"line":107},{"kind":12,"line":107,"name":"info","containerName":"test"},{"containerName":"test","name":"$self","kind":13,"line":107}]},{"name":"threads","kind":12,"line":106},{"line":107,"kind":12,"name":"Dumper"},{"signature":{"label":"new()","documentation":"# FILEPATH: Untitled-1\n\npackage Net::IPBlocker::ReviewLogDefault;\n\nuse strict;\nuse warnings;\nuse Exporter;\nuse Regexp::IPv6     qw($IPv6_re);\nuse Log::Any qw($log);  # Allegedly handles lots of different logging modules\nuse threads;\nuse Data::Dumper;\n\nlocal $Data::Dumper::Sortkeys = 1;\nlocal $Data::Dumper::Indent   = 1;\n\nour @EXPORT_OK = qw(grep_regexps);\n\nmy $logger = $log;\nmy $REGEX_IPV4 = q/\\b((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\\b/;\nmy $REGEX_IPV6      = q/\\b($IPv6_re)\\b/;\n\n=head1 NAME\n\nNet::IPBlocker::GrepRegexpsDefault - Default regular expressions for IP blocking\n\n=head1 SYNOPSIS\n\n    This works with the Net::IPBlocker module to provide a default sub for regular expressions for IP blocking.\n    This is alos a framework that could be used to create other modules that provide default regular expressions for \n    IP Blocking of particular types of files such as Apache logs, Postfix logs, Auth logs, etc.\n\n    The calling code will always pass in the log object and the log contents.\n\n=head1 DESCRIPTION\n\nThis module provides a default regular expression sub for IP blocking. \nThese regular expressions can be used with the L<Net::IPBlocker> module to match and block IP addresses.\n\n=head1 METHODS\n\n=head2 get_regexps\n\nReturns an array of default regular expressions for IP blocking.\n\n    my @regexps = Net::IPBlocker::GrepRegexpsDefault->get_regexps();\n\n\n# Description:  Using the logobj, this greps against the log contents for matching lines and then gets the\n#               IP address on each line.\n# Requires:     $self, $log\n# Returns:      Hash reference of IP addresses with count of how many times the IP address was found\nsub grep_regexps {\n    my ( $self, $log ) = @_;\n    my $TID = \"TID: \" . threads->tid;\n    $logger->debug(\"$TID|In grep_regexps in \" . __PACKAGE__ . \" module.\");\n\n    my $matches      = {};\n    my @log_contents = @{ $log->{logcontents} };\n\n    return {} if ( !@log_contents );\n\n    # DO NOT SORT NUMERICALLY!  The info in the configs states the order is sorted alphabetically\n    foreach my $regex ( sort keys %{ $log->{regexpdeny} } ) {\n        my $pattern = $log->{regexpdeny}{$regex};\n        $logger->debug(\"$TID|Grep'ing for >>$pattern<< in $log->{file} from byte position $log->{seek}\");\n\n        my @current_matches = grep { /$pattern/ } @log_contents;\n        $logger->debug( \"$TID|Dumper of current matches: \" . Dumper(@current_matches) ) if $logger->is_debug();\n\n        foreach my $line (@current_matches) {\n            chomp($line);\n            $logger->debug(\"$TID|Checking >>$line<< for IP address\");\n\n            foreach my $ip_address ( $line =~ /$REGEX_IPV4/g, $line =~ /$REGEX_IPV6/g ) {\n                $matches->{$ip_address}++;\n                $logger->debug(\"$TID|Found IP address: $ip_address\");\n            }\n        } ## end foreach my $line (@current_matches)\n    } ## end foreach my $regex ( sort keys...)\n\n    $logger->debug( \"$TID|Dump of IP matches after all regex comparisons: \" . Dumper($matches) ) if $logger->is_debug();\n\n    my $log_msg = \"$TID|Matched IP addresses to be reviewed for potential blocking: \";\n    $log_msg .= join( \",\", keys %{$matches} );\n    $logger->info($log_msg);\n\n    return $matches;\n} ## end sub grep_regexps\n\n=head2 test\n\nThis is just a simple test sub.  It is not required but is nice to have for testing.\n\nThis sub is called after the module is successfully loaded as a sanity check.\n\nYou can put whatever you want into it but returning 1 (Perl truthy) will keep a warning from happening\n\n\n# Description:  Just a test sub for a sanity check.  Not really required but nice to have for testing\n#               My lessons learned:\n#               1.  Make sure the last part of the package name actually matches the file name (without the pm)\n# Returns:      1\nsub test() {\n    my ($self) = @_;\n    my $TID = \"TID: \" . threads->tid;\n    $logger->info(\"$TID:Test sub successfull.  Dump of self: \" . Dumper($self));\n    return 1;\n}\n\n=head2 new\n\nThis is the constructor for the module.  It is not required but is nice to have.\n\nThis sub is called after the module is successfully loaded as a sanity check.\n\n Description:  Constructor for the module\n Returns:      blessed reference","parameters":[]},"range":{"start":{"line":121,"character":0},"end":{"character":9999,"line":136}},"kind":12,"children":[{"containerName":"new","localvar":"my","name":"$class","definition":"my","line":122,"kind":13},{"kind":13,"line":123,"definition":"my","name":"$args","localvar":"my","containerName":"new"},{"kind":13,"line":124,"localvar":"my","definition":"my","name":"$TID","containerName":"new"},{"line":124,"kind":12,"name":"tid","containerName":"new"},{"containerName":"new","line":125,"name":"$self","definition":"my","localvar":"my","kind":13},{"containerName":"new","name":"$args","line":126,"kind":13},{"name":"$args","kind":13,"line":127,"containerName":"new"},{"name":"$logger","kind":13,"line":130,"containerName":"new"},{"name":"info","line":130,"kind":12,"containerName":"new"},{"containerName":"new","line":131,"kind":13,"name":"$logger"},{"kind":12,"line":131,"name":"debug","containerName":"new"},{"containerName":"new","name":"$self","line":131,"kind":13},{"name":"$logger","kind":13,"line":131,"containerName":"new"},{"line":131,"kind":12,"name":"is_debug","containerName":"new"},{"name":"$self","kind":13,"line":132,"containerName":"new"},{"kind":13,"line":132,"name":"$class","containerName":"new"},{"containerName":"new","kind":13,"line":134,"name":"$logger"},{"name":"info","kind":12,"line":134,"containerName":"new"},{"kind":13,"line":134,"name":"$self","containerName":"new"},{"containerName":"new","kind":13,"line":135,"name":"$self"}],"detail":"()","containerName":"Net::IPBlocker::ReviewLogDefault","line":121,"definition":"sub","name":"new"},{"kind":12,"line":124,"name":"threads"},{"line":126,"kind":12,"name":"parentobjself"},{"kind":12,"line":126,"name":"parentobjself"},{"kind":12,"line":127,"name":"logobj"},{"name":"logobj","kind":12,"line":127},{"name":"Dumper","kind":12,"line":131},{"line":134,"kind":12,"name":"Dumper"}],"version":5}