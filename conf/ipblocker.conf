# Lines that begin with a comment (#) are ignored
# Think of each line as a a key:value setup as such: key[sub-key][sub-sub-key][sub-sub-sub-key]=value
# Duplicates are allowed.  The last one wins!
# This is being used by perl so let's keep a few thigns in mind:
#   1. False value is 0.  Period.  That's it.  0 (zero) is false.  Everything else is true.
#   2. Regular expressions are PERL regular expressions.  So they are case sensitive and use PERL regular expressions.
#   3. Unless otherwise noted, sorting is regular perl sorting.  So 1, 10, 11 come before 2, 20, 21, etc.


### Global settings 
# The global settings are used for all log files unless overridden or combined by the individual log file settings.

# The a different iptables command
#   If this is not set, then the default is `which iptables`
#   A simpe check is done to verify that the iptables command exists and is executable.
#   A good method is to use a sudo command to run iptables as a different user.
#   This also means seting up sudo to allow the user to run iptables as a different user in passwordless mode.
#   Steps to do this:
#     1.  Create a user to run the iptables command.  For example, iptablesuser
#     2.  Create a group to run the iptables command.  For example, iptablesgroup
#     3.  Add the iptablesuser to the iptablesgroup
#     4.  Add the following line to the /etc/sudoers file:
#           iptablesuser ALL=(ALL) NOPASSWD: /sbin/iptables
#     5.  Set the iptables command to the following:
#           iptables=sudo -u iptablesuser /sbin/iptables
# iptables=/usr/sbin/iptables_some_other_location
iptables=sudo /sbin/iptables

# The location of the log4perl configuration file if different than default location of /etc/ipblocker/log4perl.conf
# log4perlconf=/some/other/place/log4perl.conf

# The location of the lock file
#   If this is not set, then the default is /var/run/iptables.run
#   The lock file is used to prevent multiple instances of this script from running at the same time.
# lockfile=/some/other/directory/iptables.run

# If not set, the default value is 1
# The number of seconds to wait to check to see if there are entries in the queue to process
#   Prevents the script from going CPU crazy and checking the queue as fast as possible.
#   You can set this to 0 to check the queue as fast as possible but I would not recommend it.
# Once a queue entry is found then the queue is checked continuously until the queue is empty.
# I see very little utility in having this set to 0 or even less than 1 second.
queuechecktime=1

# Whether or not the entire log file is read each time.  If set to 0 (false), then we only read from the end of the 
#   last read (or the beginning if it is the first read or if the log file has been allegedly rotated)
#   Reading from last read is faster, but if the log file is rotated AND the log file grows larger than the 
#       last read, then we may miss some entries.
#   If this setting does not exist, then it is assumed to be 0.
#   For most situations, this should be set to 0.
#   If you rotate your log files frequently AND get a lot of traffic, then you may want to set this to 1.
readentirefile	    = 0

# # This is how many times a log file will be reviewed.
# # This is a global value and can be set for each log file individually.
# #  (Very bad naming of a variable, sorry)
# #   If this is not set, then the default is 9007199254740991
# cycles=25

# # This is how many seconds to sleep between checking a log file.
# # This is a global value and can be set for each log file individually.
# #  If this is not set, then the default is 0.5 seconds
# #  This gets a bit complex to decide but here goes:
# #  If you are always reviewing the entire log file, then this value is rather important.
# #     Reviewing the entire log file means that you are not using the "readentirefile" setting.
# cyclesleep=1

# totalruntime: This is the total amount of time that the script will run in seconds.
#   If this is not set, then the default is LONG_MAX (usually 9223372036854775807)
#   This is nice to set if you have this ran out of cron and want it to gracefully die and 
#   reload like once an hour or something.
#   Also nice for testing.
totalruntime = 120

# Process nice level on the OS
nice=15

PRODMODE=1  # Set this to a perl false value (0) to run in test mode.
            # Default is test mode. (meaning  PRODMODE=0 is the default)
            # Test mode will NOT run any iptable command but will log what it would have been done.

chainprefix=IPBLOCKER_  # If not set, default is IPBLOCKER_
                        # This is the prefix for the iptables chain names.
                        # The chain names are created as follows:
                        #   ${chainprefix}${logname}
                        #  All actions are performed from ${chainprefix}global
                        # The default is IPBLOCKER_ but you can change it if you want.
                        # When you do an 'iptables -nvL' you will see the chain prefix in the chain names.

globalchains=INPUT,OUTPUT,FORWARD   # If not set, default is INPUT,OUTPUT,FORWARD
                                    # These are the chains that {chainprefix}global will be added to.
                                    # All other logger chains will be added to {chainprefix}global
                                    # The logger rules are then added to the logger chains.
                                    # Instead of adding the rules to the INPUT,OUTPUT,FORWARD chains, you can
                                    #   add them to a different chain.  For example, you could add them to a chain
                                    #   called "MailServer" and then that chain would have to be added to the
                                    #  INPUT,OUTPUT,FORWARD chains (or whatever chains you want).
                                    #  This might be useful to change if you want to add the rules to a dummy chain but
                                    #  is not actually used.... maybe for pre-production testing or something.
                                    #  Or, maybe you only want rules acted on the INPUT chain and not the OUTPUT chain.
                                    #  Having FORWARD is a bit aggressive but to each their own.
                                    #  This value must be a comma separated.  No spaces.

# Deny list of IPs:  deny these IPs, almost always.  The allowdeny value takes precedence when order of allowdeny
# is set.  See below.
# The denylist is added to the individual log file denylist.
denylist[01]							= 165.232.121.37
denylist[02]							= 165.232.121.36

# Allow list of IPs:  allow these IPs, almost always.  The allowdeny value takes precedence when order of allowdeny
# is set.  See below.
# The allowlist is added to the individual log file allowlist.
allowlist[00]							= 75.87.147.162
allowlist[01]							= 64.250.56.204
allowlist[02]							= 192.73.248.201
allowlist[03]							= 199.38.182.248
allowlist[04]							= 158.69.195.66
allowlist[05]							= 185.34.216.102
allowlist[06]							= 192.73.241.233
allowlist[07]							= 192.73.241.56
allowlist[08]							= 198.251.81.67
allowlist[09]							= 198.50.163.67
allowlist[10]							= 199.195.248.92
allowlist[11]							= 204.109.63.3
allowlist[12]							= 208.86.227.242
allowlist[13]							= 209.177.157.147
allowlist[14]							= 81.4.124.103
allowlist[15]							= 91.189.91.38
allowlist[16]							= 185.34.3.136
allowlist[17]							= 20.245.57.59
allowlist[18]							= 3.3.3.3

# Individual log files settings for this value take precedence over the general settings here
#   Allow,Deny means that the allowlist is processed first and then the denylist is processed.
#      Items in the allowlist will be allowed even if they are in the denylist.
#   Deny,Allow means that the denylist is processed first and then the allowlist is processed.
#      Items in the denylist will be denied even if they are in the allowlist.
#  I would not change this unless you know what you are doing.  You have the potential to lock yourself out of your
#  own system.
allowdeny                               = Allow,Deny


### Not yet implemented....
# Finds the IPs of each interface and adds them to the allow list.
#  Some logs have the IP of the interface in the log file.
#  This is a perl true/false value.  If it is set to 0 (false) then the IPs of each interface will be added to 
#  the allowlist.
#  If you keep allowdeny set  to Allow,Deny then this will keep you from blocking your own IPs.
#    Or, at least that is the idea!  This is totally based on Net::Ifconfig::Wrapper so... do some testing
#    to make sure that it is working as expected.
#  I encourage leaving this as 0 (false) but it is here if you need it.  
#  The default value, if not set, is 0 (false)
# ignoreinterfaceips=0

### End of Global settings



# Settings for each log file from here down

### The authlog settings:
# The "logs_to_review" hash is a list of log files to review.  Each log file has a unique name.  The name is used 
#   to reference the log file in other parts of the configuration file.
#   In the exampple of "authlog", the string "authlog" could be any alphanumeric string.  It is just used for reference.

# load:  This is a perl true/false value.  If it is set to 1 (true) then the log file will be reviewed.
#   This is just an easy way to keep configs in here but the script/module will not review the log file.
logs_to_review[authlog][load] 				    = 1

# file: The "file" value is the location of the log file to review.
# logs_to_review[authlog][file]				    = /var/log/auth.log
logs_to_review[authlog][file]				    = /home/gardner/var/log/auth.log

# readentirefile: Whether or not the entire log file is read each time.  If set to 0 (false), then we only read from 
#   the end of the last read (or the beginning if it is the first read or if the log file has been allegedly 
#   rotated)
#   Reading from last read is faster, but if the log file is rotated AND the log file grows larger than the last 
#   read, then we may miss some entries.
#   If this setting does not exist, then it is assumed to be 0.
#   For most situations, this should be set to 0.
#   If you rotate your log files frequently AND get a lot of traffic, then you may want to set this to 1.
#   For now, the script/module is pretty dumb about this.  When set to 0, the entire file is reread if the file size
#   is less than the last read.
#   This should be enhanced to check the inode, file size, last change time, etc.  But for now, it is pretty dumb.
logs_to_review[authlog][readentirefile]	    = 0

# grepmodule and libpath:  This is the module that will be used to grep the log file.
#   If the module is not set, then the default is Net::IPBlocker::GrepRegexpsDefault
#   This is the literal name of the module that will be used to grep the log file.
#   The Log Contents and all configs associated with the log file are passed to the module as a hash reference.
#   The module must have an exported function called "grep_regexps_<logname>" that takes the hash reference as an argument.
#   The module must return a hash reference of IP addresses with optionally a count of how many times the IP address 
#   was found.  The IP addresses are the keys of the hash reference and the count is the value.
#   The IP addresses are then blocked according to the configuration settings for the log file.
#   If you need to add a library path then it be done with the libpath key.
#   As an example: if you have a special module that you want to use for the authlog in a special location then you
#   would set the libpath to the library path and the grepmodule to the module name.
#   Meaning: let's say you are keeping your special libraries in /home/johnboy/git/ipblockerclassified/Net-IPBlocker/lib/
#   and you have your special module in:
#     /home/johnboy/git/ipblockerclassified/Net-IPBlocker/lib/Net/IPBlocker/GrepRegexpsSpecial.pm
#   Then you would set the libpath to /home/johnboy/git/ipblockerclassified/Net-IPBlocker/lib/ and the grepmodule to
#   Net::IPBlocker::GrepRegexpsSpecial
#   Like this:
#   logs_to_review[authlog][libpath]            = /home/johnboy/git/ipblockerclassified/Net-IPBlocker/lib/
#   logs_to_review[authlog][grepmodule]     	= Net::IPBlocker::GrepRegexpsSpecial
logs_to_review[authlog][libpath]            = /home/gardner/git/ipblockerclassified/Net-IPBlocker/lib/
# logs_to_review[authlog][grepmodule]     	= Net::IPBlocker::GrepRegexpsDefault
logs_to_review[authlog][grepmodule]     	= Net::IPBlocker::GrepRegexpsSSHD

# cycles: cycles and cyclessleep
#   The number of times the log file will be reviewed.
logs_to_review[authlog][cycles]                 = 10
# cyclesleep:  The number of seconds to sleep between cycles.  Can be partial seconds.  So 0.5 is a half second.
logs_to_review[authlog][cyclesleep]             = 1.5

# protocols:  This is the protocol(s) that will be blocked in the firewall.
#   If the protocol is not set, then the default is no protocol.
#   You do not have to set protocol unless you set ports.
#   If you set ports but not protocol then the script will add the IP to the firewall but will not add the protocol and
#     thus no ports.  So, the entire IP will be blocked.
#   There is no checking if the protocol is valid.  So if you set protocol=blah then the script will give an error 
#     when the rule is tries to be added to the firewall.
#   Must be separated by non-alphanumeric-digit characters.  So tcp,udp is good.  tcp udp is good.  tcp-udp is good.
#    The "_" character is not allowed.  So tcp_udp is not good.
#    Most folks will use commas but whatever floats your boat.
logs_to_review[authlog][protocols]              = tcp,udp

# ports: This is the port(s) that will be matched for blocking of IPs in the log file.
#   If the ports are not set, then the default is no ports.
#   You do not have to set ports but if you do, then you must set protocol.
#   Example:  ports=22,21,23 means that the script will block IPs that are trying to connect to ports 22, 21, and 23.
#   Must be separated by commas and ranges are accepted.  Maximum of 15 comma separated values.
# Example 1:  logs_to_review[authlog][ports]                  = 22,21,23
# Example 2:  logs_to_review[authlog][ports]                  = 22,21,23,1000:2000,3000:4000
# Example 3:  logs_to_review[authlog][ports]                  = 22,21,23,1000:2000
# Bad ports will log as an error and the rule will not be added.
# If you set ports but no protocol then the entire IP will be blocked on the protocol.
# logs_to_review[authlog][ports]                  = 22,21,23

# directions:  This is the direction(s) that will be blocked in the firewall.
#   If the direction is not set, then the default is source
#  Must be separated by non-digit-alphanumeric characters.  So source,destination is good.  source destination is good.
#   source-destination is good.
#   The "_" character is not allowed.  So source_destination is not good.
#  Most folks will use commas but whatever floats your boat.
#  Accepted values are source, destination, random
# Example 1:  logs_to_review[authlog][direction]              = source,destination
# Example 2:  logs_to_review[authlog][direction]              = source
# Example 3:  logs_to_review[authlog][direction]              = destination
# Example 4:  logs_to_review[authlog][direction]              = source,destination,cool,blah,blah,blah
# In example 4, only source and destination will be used.  The values of cool,blah,blah,blah will be ignored.
# I think most folks will not set this or just use 'source' but I can see value in blocking the destination as well.
# If you want to really screw with hackers, then set this to 'destination' and then they will not get any response
# The "random" value will ignore (for now) any other value set.  If randiom is used then source or 
# destination will be randomly chosen for each IP rule.
# logs_to_review[authlog][directions]          = source,destination
# logs_to_review[authlog][directions]          = destination
# logs_to_review[authlog][directions]          = random

# allowdeny
#  This is the order preference for whitelisted and blacklisted IPs.
#  If the order is set to "Deny,Allow" then blacklisted IPs will ALWAYS be 
#    blocked (even if they are in the whitelisted hash)!
#  If the order is set to "Allow,Deny" then whitelisted IPs will ALWAYS be 
#    allowed (even if they are in the blacklisted hash)!
#  If the order is not set or is set incorrectly then the default is "Allow,Deny"
#  When using authlog, I would reccomend setting the order to "Allow,Deny" so that whitelisted IPs are always allowed 
#    for ssh.
#  The order is case insensitive.
logs_to_review[authlog][allowdeny]          = Allow,Deny

# allowlist: List of IPs to allow just for this log file
logs_to_review[authlog][allowlist][01]     =  1.1.1.1
logs_to_review[authlog][allowlist][02]     =  2.2.2.2
logs_to_review[authlog][allowlist][03]     =  3.3.3.3
logs_to_review[authlog][allowlist][04]     =  4.4.4.4
logs_to_review[authlog][allowlist][05]     =  23.116.91.65
logs_to_review[authlog][allowlist][05]     =  23.116.91.66
logs_to_review[authlog][allowlist][06]     =  23.116.91.67
logs_to_review[authlog][allowlist][07]     =  23.116.91.68

# denylist: List of IPs to block just for this log file
logs_to_review[authlog][denylist][01]      =  5.5.5.5
logs_to_review[authlog][denylist][02]      =  6.6.6.6

# regexpdeny: Each regular expression must have a unique value.  
#   This is just typically indexed as 01, 02, 03, 04, etc.  But it can be any Alphanumeric
#   The index is sorted in simple Perl sort.  So 1, 10, 11 come before 2, 20, 21, etc.
#   Also, lowercase will come before uppercase.  So a, b, c, A, B, C.
#   The sorting may matter because the regular expressions are applied in order.
#   Regular expressions are case insensitive therefore "Failed" is the same as "fAiLed"
#   Regular expressions Perl regular expressions so you can do fancy *.?[]{}() stuff.
logs_to_review[authlog][regexpdeny][01]  		= Failed password for root from
logs_to_review[authlog][regexpdeny][02]  		= Failed password for invalid user  
logs_to_review[authlog][regexpdeny][03]  		= Did not receive identification string from
logs_to_review[authlog][regexpdeny][04]  		= not allowed because listed in DenyUsers

# Special use cases for particular loggers is not yet implemented.
# # Authlog has a special value of allowed usernames
# logs_to_review[authlog][allowedusername][01]    = gardner
# logs_to_review[authlog][allowedusername][02]    = jiggerboy
# # Authlog has a special value of not-allowed usernames
# logs_to_review[authlog][deniedusername][01] 	= root

# Special items for Net::IPBlocker::GrepRegexpsSSHD
# filterin: Before looking for IPs based on "regexpdeny" the log file is filtered for lines that match these regex
# filterout: After "filterout" and before "regexpdeny" the log file is filtered for lines that do not match these regex
logs_to_review[authlog][filterin][01]        = sshd
logs_to_review[authlog][filterout][01]       = sshd.*for gardner



#### Now... an example without comments

### The maillog settings:
logs_to_review[maillog][load] 				= 0
logs_to_review[maillog][file]				= /var/log/mail.log
logs_to_review[maillog][libpath]            = /home/gardner/git/ipblockerclassified/Net-IPBlocker/lib
logs_to_review[maillog][grepmodule]     	= Net::IPBlocker::GrepRegexpsMail
logs_to_review[maillog][cycles]             = 1000
logs_to_review[maillog][cyclesleep]         = 1.45
logs_to_review[maillog][order]              = Allow,Deny 
logs_to_review[maillog][regexpdeny][1] 		= Relay access denied,Illegal address syntax from
logs_to_review[maillog][regexpdeny][2]		= SASL LOGIN authentication failed
logs_to_review[maillog][regexpdeny][3]		= SSL_accept error from
logs_to_review[maillog][regexpdeny][4]		= lost connection after AUTH from unknown
logs_to_review[maillog][regexpdeny][5]		= 503 5.5.1 Error: authentication
logs_to_review[maillog][regexpdeny][6]		= disconnect from.* commands=0\/0
logs_to_review[maillog][regexpdeny][7]		= non-SMTP command from unknown
logs_to_review[maillog][regexpdeny][8]		= connect to.*:25: Connection refused