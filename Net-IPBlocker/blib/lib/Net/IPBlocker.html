<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Net::IPBlocker - Blocks IPs based on regex from specified log files</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a>
    <ul>
      <li><a href="#Future-Enhancements">Future Enhancements</a></li>
      <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
    </ul>
  </li>
  <li><a href="#SUBROUTINES-METHODS">SUBROUTINES/METHODS</a>
    <ul>
      <li><a href="#new">new</a>
        <ul>
          <li><a href="#All-arguments-to-new-and-the-defaults">All arguments to new() and the defaults</a>
            <ul>
              <li><a href="#allowdeny">allowdeny</a></li>
              <li><a href="#allowlist">allowlist</a></li>
              <li><a href="#configsfile">configsfile</a></li>
              <li><a href="#cycles">cycles</a></li>
              <li><a href="#cyclesleep">cyclesleep</a></li>
              <li><a href="#dumpconfigsandexit">dumpconfigsandexit</a></li>
              <li><a href="#denylist">denylist</a></li>
              <li><a href="#forceremovelockfile">forceremovelockfile</a></li>
              <li><a href="#chainprefix">chainprefix</a></li>
              <li><a href="#globalchains">globalchains</a></li>
              <li><a href="#iptables">iptables</a></li>
              <li><a href="#lockfile">lockfile</a></li>
              <li><a href="#log4perlconf">log4perlconf</a></li>
              <li><a href="#loglevel">loglevel</a></li>
              <li><a href="#prodmode">prodmode</a></li>
              <li><a href="#queuechecktime">queuechecktime</a></li>
              <li><a href="#queuecycles">queuecycles</a></li>
              <li><a href="#readentirefile">readentirefile</a></li>
              <li><a href="#totalruntime">totalruntime</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#go">go</a></li>
    </ul>
  </li>
  <li><a href="#Sample-config-file">Sample config file</a></li>
  <li><a href="#Example-Script">Example Script</a></li>
  <li><a href="#Example-log-config">Example log config</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#SUPPORT">SUPPORT</a></li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
  <li><a href="#LICENSE-AND-COPYRIGHT">LICENSE AND COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Net::IPBlocker - Blocks IPs based on regex from specified log files</p>

<h1 id="VERSION">VERSION</h1>

<p>Version 0.01</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>Blocks IPs based on Regular Expressions in specified log files.</p>

<pre><code>use Net::IPBlocker;
my $foo = Net::IPBlocker-&gt;new();
$foo-&gt;go(); </code></pre>

<p>You can send all configs into the constructor as a hash, I really advise using a config file. The default config file is <i>/etc/ipblocker/ipblocker.conf</i> but you can set it to another file. If a config file is not found, it will use default values for everything and that will probably not work very well.</p>

<pre><code>my $foo = Net::IPBlocker-&gt;new( { configsfile =&gt; &#39;/etc/ipblocker/ipblocker.conf&#39; } );
$foo-&gt;go();</code></pre>

<h2 id="Future-Enhancements">Future Enhancements</h2>

<ul>

<li><p>Add reload ability of configs</p>

<p>This will make it so a full stop and restart does not need to happen to reload configs.</p>

</li>
<li><p>Add jail time for IPs</p>

<p>This involves adding a database to store the IPs and the time they were blocked. This also means adding a mechanism to unblock IPs after a certain amount of time. Luckily, I have threaded this so adding that is just a matter of adding another thread. I am open to ideas of what database to use. I am thinking SQLite. Or, possibly just a file with the IPs (the rule) and the time they are to be unblocked (deleted from iptables).</p>

</li>
<li><p>Add synchronized appender logging:</p>

<p>https://metacpan.org/dist/Log-Log4perl/view/lib/Log/Log4perl/Appender/Synchronized.pm</p>

</li>
<li><p>Fix the ability for Log4perl to re-read the &quot;log4perl.conf&quot; which seems to not work right now</p>

</li>
<li><p>Change from using log4perl to Log::Any</p>

<p>I didn&#39;t know about Log::Any when I started this. I am open to changing this to Log::Any but I need to figure out how to do that.</p>

</li>
<li><p>my $interfaces = Net::Ifconfig::Wrapper::Ifconfig(&#39;list&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;);</p>

<p>This is a list of interfaces. Need to figure out how to use this to get the IP address of the interfaces. Need to add those IPs to the global allow list.</p>

</li>
<li><p>Fix sub add_ifconfig_ips_to_allowlist() to handle IPv4 and IPv6 addresses</p>

<p>This really findes the IPs on a network interface and adds them to the global allow list. Usually,we don&#39;t want to accidentally block our own IPs. Of course, this will mean adding an option to the configs file to turn this on or off.</p>

</li>
</ul>

<h2 id="DESCRIPTION">DESCRIPTION</h2>

<p>This has been a very long running project of mine. I have been using this script for years to block IPs and then realized Fail2Ban exists. I have tried to use Fail2Ban multiple times but it never seems to work right for me. It seems to lock-up. This module tries to incorporate the ideas of my past experience with the general idea of Fail2Ban.</p>

<p>I highly encourage you to use a config file. The default config file is in the same location as this module but you can set it to another file.</p>

<p>When installing this, you should also receive a script called &quot;ipBlocker.pl&quot;. This is a sample script that uses this module.</p>

<p>Finally, for now, this module use log4perl. I didn&#39;t realize there was a heated debate about log4perl vs Log::Any vs whatever else. I am open to changing this to Log::Any but I need to figure out how to do that.</p>

<h1 id="SUBROUTINES-METHODS">SUBROUTINES/METHODS</h1>

<h2 id="new">new</h2>

<p>Reads configs from a file if exists otherwise uses defaults. Sets up a class and returns a blessed &quot;object&quot;. The sub go() is where the action starts. The sub new() just gets a few things setup.</p>

<p>Example:</p>

<pre><code>use IPblocker;

my $args = {
  configsfile         =&gt; &#39;/etc/ipblocker/ipblocker.conf&#39;,
  dumpconfigsandexit  =&gt; &#39;0&#39;, # True false value
  forceremovelockfile =&gt; &#39;0&#39;, # True false value
  iptables            =&gt; &#39;sudo /sbin/iptables&#39;,
  lockfile            =&gt; &#39;/var/run/ipblocker.run&#39;,
  log4perlconf        =&gt; &#39;/etc/ipblocker/log4perl.conf&#39;,  #Can also be 0 to use default log4perl
  loglevel            =&gt; &#39;DEBUG&#39;, # Can be TRACE DEBUG INFO WARN ERROR FATAL
  prodmode            =&gt; &#39;0&#39;, # True false value --- Determins if the iptables commands are actually run
  queuechecktime      =&gt; &#39;3&#39;, # How long to wait when the queue is empty before checking again. Any float value.
  readentirefile      =&gt; &#39;0&#39;, # True false value --- Determines if the entire log file is read or
                              # new entries since last run are read.
  cycles              =&gt; &#39;LONG_MAX&#39;, # How many times to run the main loop.  LONG_MAX is the default.
  ### All configs can be set via a hash reference
};

my $ipb    = IPblocker-&gt;new($args);</code></pre>

<h3 id="All-arguments-to-new-and-the-defaults">All arguments to new() and the defaults</h3>

<h4 id="allowdeny">allowdeny</h4>

<p>allowdeny =&gt; &#39;Allow,Deny&#39;,</p>

<p>Set to &#39;Allow,Deny&#39; or &#39;Deny,Allow&#39; to determine the order of the allow and deny lists. Seteting to &#39;Allow,Deny&#39; means the allow list is processed first and then the deny list is processed. Meaning, as an example, if 1.1.1.1 is on the allow list and allowdeny is set to Allow,Deny, then the IP of 1.1.1.1 will never be blocked. If allowdeny is set to Deny,Allow, then it is possible for 1.1.1.1 to be blocked.</p>

<h4 id="allowlist">allowlist</h4>

<p>allowlist =&gt; {},</p>

<p>A list of IPs to allow. This is a hash reference. The key is the order to allow the IP. The value is the IP. Example:</p>

<pre><code>allowlist =&gt; (
 &#39;01&#39; =&gt; &#39;1.1.1.1&#39;,
 &#39;4&#39; =&gt; &#39;1.1.1.4&#39;,
 &#39;10&#39; =&gt; &#39;1.1.1.2&#39;,
 &#39;100&#39; =&gt; &#39;1.1.1.3&#39;,
 
)</code></pre>

<p>The allow list is sorted in standard Perl sort order. So, be sure to pad 0&#39;s or whatever to the front of the key.</p>

<h4 id="configsfile">configsfile</h4>

<p>configsfile =&gt; &#39;/etc/ipblocker/ipblocker.conf&#39;,</p>

<p>Use a config file! This is the default config file location. You can set it to another file.</p>

<h4 id="cycles">cycles</h4>

<p>cycles =&gt; LONG_MAX,</p>

<p>How many times to run the main loop. LONG_MAX is the default. Why not infinity? Because I don&#39;t want to.</p>

<h4 id="cyclesleep">cyclesleep</h4>

<p>cyclesleep =&gt; 0.5,</p>

<p>How long to sleep between cycles. This is in seconds. Default is 0.5 seconds. You can use a float value.</p>

<h4 id="dumpconfigsandexit">dumpconfigsandexit</h4>

<p>dumpconfigsandexit =&gt; 0,</p>

<p>If set to 1 (true), then the configs are dumped to stdout and the script exits. This is useful for creating a config file.</p>

<h4 id="denylist">denylist</h4>

<p>denylist =&gt; {},</p>

<p>Similar to allow list but for IPs to deny. This is a hash reference. The key is the order to deny the IP.</p>

<h4 id="forceremovelockfile">forceremovelockfile</h4>

<p>forceremovelockfile =&gt; 0,</p>

<p>This will force removal of lock file (if possible) before starting. Seriously, you better know what you are doing.</p>

<h4 id="chainprefix">chainprefix</h4>

<p>chainprefix =&gt; &quot;IPBLOCKER_&quot;,</p>

<p>This is the prefix for the chains created in iptables. This is the prefix you will see in iptables for all the chains created by this module.</p>

<h4 id="globalchains">globalchains</h4>

<p>globalchains =&gt; [qw / INPUT OUTPUT FORWARD /],</p>

<p>This is a list of the global chains to add the global chain to. The global chain is where all the subordinate file logger chains are added.</p>

<p>I see some value in adding the global chain to some other chain but by default we add it to INPUT, OUTPUT, and FORWARD. Or, possibly, you don&#39;t want to add to the FORWARD chain. Maybe you onkly care about INPUT table. I don&#39;t know. Whatever works best for you.</p>

<h4 id="iptables">iptables</h4>

<p>iptables =&gt; &#39;/sbin/iptables&#39;,</p>

<p>This is the iptables command to use. You can use sudo or whatever you want. I really encourage using sudo but by default it is not used. Using sudo and non-root user is a bit more work. You need to setup sudoers to allow the user to run iptables. However, I think it is worth it for an added measure of security. If you change this to use sudo, then you may also need to change the lockfile location to a location that the user can write to.</p>

<h4 id="lockfile">lockfile</h4>

<p>lockfile =&gt; &#39;/var/run/ipblocker.run.default&#39;,</p>

<p>This is the lock file location to use to try to prevent multiple instances from running.</p>

<h4 id="log4perlconf">log4perlconf</h4>

<p>log4perlconf =&gt; &#39;/etc/ipblocker/log4perl.conf&#39;,</p>

<p>This is the log4perl configuration file to use. You can also set this to 0 to use the default log4perl configuration.</p>

<h4 id="loglevel">loglevel</h4>

<p>loglevel =&gt; &#39;INFO&#39;</p>

<p>THis can be TRACE DEBUG INFO WARN ERROR FATAL.</p>

<h4 id="prodmode">prodmode</h4>

<p>prodmode =&gt; 0,</p>

<p>This is a true/false value. If set to 1 (true), then the iptables commands are actually run. If set to 0 (false), then the iptables commands are not run. This is useful for testing.</p>

<p>By default, this is set to 0 (false).</p>

<h4 id="queuechecktime">queuechecktime</h4>

<p>queuechecktime =&gt; 1,</p>

<p>When the queue is empty, how long to wait before checking again. When the queue is not empty, this value is ignored</p>

<h4 id="queuecycles">queuecycles</h4>

<p>queuecycles =&gt; LONG_MAX,</p>

<p>How many times to check the queue. LONG_MAX is the default. Why not infinity? Because I don&#39;t want to. None of my relationships lasted forever and I don&#39;t think you running this module should be indefinite.</p>

<h4 id="readentirefile">readentirefile</h4>

<p>readentirefile =&gt; 0,</p>

<p>This is a true/false value. If set to 1 (true), then the entire log file is read. If set to 0 (false), then only new entries since the last run are read. This can aslo be set per log file in the configs file.</p>

<h4 id="totalruntime">totalruntime</h4>

<p>totalruntime =&gt; LONG_MAX,</p>

<p>How long to run in seconds. This is irrespective of any other cycle or queue cycle. Nice for testing or maybe you want to run this for a certain amount of time and restart it out of cron or something.</p>

<h2 id="go">go</h2>

<p>This is where the action starts. This is called from the script that uses this module after new() is instantiated.</p>

<p>This creates a thread for each log watcher and a thread for the iptables queue watcher. As an example, if you have 5 files to watch, then there will be 5 threads watching those files + 1 thread to add commands to iptables. Worst case scenario, you may need 1 CPU per thread (at most). However, that is very unlikely because the timing of processing will vary and it is not really a 1:1 ratio.</p>

<h1 id="Sample-config-file">Sample config file</h1>

<pre><code>Default location: /etc/ipblocker/ipblocker.conf

# Lines that begin with a comment (#) are ignored
# Think of each line as a a key:value setup in the following manner: key[sub-key][sub-sub-key][sub-sub-sub-key]=value
# Duplicates are allowed.  The last one wins!
# This is being used by perl so let&#39;s keep a few thigns in mind:
#   1. False value is 0.  Period.  That&#39;s it.  0 (zero) is false.  Everything else is true.
#   2. Regular expressions are PERL regular expressions.  So they are case sensitive and use PERL regular expressions.
#   3. Unless otherwise noted, sorting is regular perl sorting.  So 1, 10, 11 come before 2, 20, 21, etc.


### Global settings 
# The global settings are used for all log files unless overridden or combined by the individual log file settings.

# iptables: Default value is `which iptables`
#           Sets a different iptables command
#           A simple check is done to verify the iptables command exists and is executable.
#           Let&#39;s talk security!
#               Running iptables as root is a bit of a security risk.  If possible set the iptables command to run as 
#               a different user.
#               A good method is to use a sudo command to run iptables as a different user.
#               This also means setting up sudo to allow the user to run iptables as a different user in passwordless mode.
#               As part of a sudo rule, be sure to allow &quot;-N&quot;, &quot;-A&quot;, &quot;-D&quot;, and &quot;-X&quot;
#               If you want to lock things down a bit, then you may want to set the sudo rule to only allow something like:
#                   iptablesuser ALL=(ALL) NOPASSWD: /sbin/iptables -N *IPBLOCKER_*
#                   iptablesuser ALL=(ALL) NOPASSWD: /sbin/iptables -A *IPBLOCKER_*
#                   iptablesuser ALL=(ALL) NOPASSWD: /sbin/iptables -D *IPBLOCKER_*
#                   iptablesuser ALL=(ALL) NOPASSWD: /sbin/iptables -X *IPBLOCKER_*
#               This will allow the iptablesuser to create, add, delete, and delete the chain
#               Take note &quot;IPBLOCKER_&quot; is the value of the &quot;chainprefix&quot;.  If you change the chainprefix then you
#               will need to change the sudo rule.
#               General steps to setup sudo rule this:
#                 1.  Create a user to run the iptables command.  For example, iptablesuser
#                 2.  Create a group to run the iptables command.  For example, iptablesgroup
#                 3.  Add the iptablesuser to the iptablesgroup
#                 4.  Add the following line to the /etc/sudoers file:
#                       iptablesuser ALL=(ALL) NOPASSWD: /sbin/iptables
#                      Or, add the four lines above --- again the four lines are a guess and may not be correct.                        
#                 5.  Set the iptables command to the following:
#                       iptables=sudo -u iptablesuser /sbin/iptables
#               Maybe in the future I&#39;ll figure out how to setup an APT/deb/Ubuntu package to do this for you.
#                   Lord knows, I&#39;ll never setup a YUM package to do this!
# iptables=sudo -u iptablesuser /sbin/iptables
# iptables=/usr/sbin/iptables_some_other_location
iptables=sudo /sbin/iptables

# log4perlconf: Default value is /etc/ipblocker/log4perl.conf
#               The location of the log4perl configuration file.
# log4perlconf=/some/other/place/log4perl.conf

# lockfile: Default is /var/run/iptables.run
#           The location of the lock file
#           The lock file is used to try to prevent multiple instances of this script from running at the same time.
#           This is a bit better than &quot;dumb&quot; but not foolproof.  The module checks the PID in the lock file to see if
#               that PID is still running.  If the PID is not running then the lock file is removed and the module 
#               will continue.
#           I realize this is a bit beyond the scope of a module but we are jacking around with iptables so let&#39;s try 
#               to be a bit safe.
# lockfile=/some/other/directory/iptables.run

# queuechecktime:   Default value is 1
#                   The number of seconds to wait to check to see if there are entries in the queue to process
#                     Prevents the script from going CPU crazy and checking the queue as fast as possible.
#                     You can set this to 0 to check the queue as fast as possible but I would not recommend it.
#                   Once a queue entry is found then the queue is processed continuously until the queue is empty.
#                   I see very little utility in having this set to 0 or even less than 1 second.
queuechecktime=3

# queuecycles:  Default value is LONG_MAX (usually 9223372036854775807)
#               When the queue is empty, this integer is decremented every &quot;queuechecktime&quot; seconds.
#               When this hits zero, the queue is set to end(), no other items are allowed on the queue, and the 
#               module will end.
#               This is nice to set for some testing and you want the script to end after a certain number of cycle 
#               checks of the queue when the queue is empty.
#               In normal operation, this should not be set and will default to LONG_MAX.
# queuecycles=40

# readentirefile:   Default value is 0 (false)
#                   Whether or not the entire log file is read each time.  If set to 0 (false), then we only read 
#                   from the end of the last read (or the beginning if it is the first read or if the log file has 
#                   been allegedly rotated)
#                   Reading from last read is faster, but if the log file is rotated AND the log file grows larger 
#                   than the last read, then we may miss some entries.
#                   For most situations, this should be left as the default of 0.
#                   If you rotate your log files frequently AND get a lot of traffic, then you may want to 
#                   set this to 1.
#                   Future enhancement: This should be enhanced to check the inode, file size, last change time, etc.
readentirefile = 0

# cycles:   Default value is LONG_MAX (usually 9223372036854775807)
#           This is how many times a log file will be reviewed.
#           This is a global value and can be set for each log file individually.
#           (Very bad naming of a variable, sorry)
# cycles=25

# cyclesleep:   Default is 0.5 seconds
#               This is how many seconds to sleep between checking a log file.
#               This is a global value and can be set for each log file individually.
#                This gets a bit complex to decide but here goes:
#                If you are always reviewing the entire log file, then this value is rather important.
#                   Reviewing the entire log file means that you are not using the &quot;readentirefile&quot; setting.
#               Usually, if you want to change this then you will want to change it for each log file individually.
#               Example: If you want to read the auth.log file every 5 seconds then you would set this to 5.
#               The module will seek to the last read position and then read the log file from there.  Of course, if
#               &quot;readentirefile&quot; is set to 1 then the entire file is read each time.
#               For those of you concerned about the performance of the system, this is a read action so it should be 
#               pretty fast, even for &quot;slow&quot; systems.
# cyclesleep=1

# totalruntime: Default is LONG_MAX (usually 9223372036854775807) seconds
#               This is the total amount of time that the script will run in seconds.
#               This is nice to set if you have this ran out of cron and want it to gracefully die and reload like 
#               once an hour or something.
#               Also nice for testing.
# totalruntime = 120

# nice:     Default is 0
#           Process nice level on the OS
# nice=15  # Not yet implemented

# PRODMODE: Default is 0 (false)
#           Set this to a perl true value (1) to run in prod mode.
#           Test mode is 0 (false) and will NOT run any iptable command but will log what it would have been done.
PRODMODE=1

# chainprefix:  Default is IPBLOCKER_
#               This is the prefix for the iptables chain names.
#               The chain names are created as follows:
#                 ${chainprefix}${logname}
#                All actions are performed from ${chainprefix}global
#               The default is IPBLOCKER_ but you can change it if you want.
#               When you do an &#39;iptables -nvL&#39; you will see the chain prefix in the chain names.
chainprefix=IPBLOCKER_

# globalchains: Default is INPUT,OUTPUT,FORWARD
#               These are the chains that {chainprefix}global will be added to.
#               All other logger chains will be added as an iptables jump rule to {chainprefix}global
#               The logger rules are then added to the logger chains.
#               Instead of adding the rules to the INPUT,OUTPUT,FORWARD chains, you can
#                 add them to a different chain.  For example, you could add them to a chain
#                 called &quot;MailServer&quot; and then that chain would have to be added to the
#                INPUT,OUTPUT,FORWARD chains (or whatever chains you want).
#                This might be useful to change if you want to add the rules to a dummy chain but
#                is not actually used.... maybe for pre-production testing or something.
#                Or, maybe you only want rules acted on the INPUT chain and not the OUTPUT chain.
#                Having FORWARD is a bit aggressive but to each their own.
#                This value must be a comma separated.  No spaces.
globalchains=INPUT,OUTPUT,FORWARD

# denylist:  Deny these IPs, almost always.  The &quot;allowdeny&quot; value takes precedence.  See below.
#            This denylist is added to the &quot;chainprefix&quot; global chain.
denylist[01]=165.232.121.37
denylist[02]=165.232.121.36

# allowlist:    Allow these IPs, almost always.  The allowdeny value takes precedence.  See below.
#               The allowlist is added to the &quot;chainprefix&quot; global chain.
allowlist[01]=23.116.91.64/29
allowlist[02]=127.0.0.0/8
allowlist[03]=10.0.0.0/8
allowlist[04]=192.168.0.0/16
allowlist[05]=172.16.0.0/12


# allowdeny:    Individual log file settings for this value take precedence over the general settings here
#                Allow,Deny means that the allowlist is processed first and then the denylist is processed.
#                   Items in the allowlist will be allowed even if they are in the denylist.
#                Deny,Allow means that the denylist is processed first and then the allowlist is processed.
#                   Items in the denylist will be denied even if they are in the allowlist.
#               I would not change this unless you know what you are doing.  You have the potential to lock yourself out of your
#               own system.
allowdeny=Allow,Deny

# minlogentry:   Default is 300 seconds
#                This is the minimum amount of time in seconds to pass before the module will give some kind of
#                INFO message.
#                Details:  A queue is used for all the activity for iptables.  A while loop runs and checks the
#                queue for entries every second.  If at least minlogentry seconds have passed since an entry then an 
#                INFO message is logged.  
#                This is to prevent the log from being filled with messages but still let you know that the script 
#                is running.
#                For systems with a lot of IPs to block then set this higher.  For systems with very few IPs to
#                block then set this lower. 
#                This is actually a very low hit to the system so I would not worry about it too much.
minlogentrytime=10


### Not yet implemented....
# ignoreinterfaceips:   Finds the IPs of each interface and adds them to the allow list.
#                       Some logs have the IP of the interface in the log file.
#                       This is a perl true/false value.  If it is set to 0 (false) then the IPs of each interface 
#                       will be added to the allowlist.
#                       If you keep allowdeny set  to Allow,Deny then this will keep you from blocking your own IPs.
#                         Or, at least that is the idea!  This is totally based on Net::Ifconfig::Wrapper so... do 
#                         some testing to make sure that it is working as expected.
#                       I encourage leaving this as 0 (false) but it is here if you need it.  
#                       The default value, if not set, is 0 (false)
# ignoreinterfaceips=0  # Not yet implemented

### End of Global settings



# Settings for each log file from here down

### The authlog settings:
# The &quot;logs_to_review&quot; hash is a list of log files to review.  Each log file has a unique name.  The name is used 
#   to reference the log file in other parts of the configuration file.
#   In the exampple of &quot;authlog&quot;, the string &quot;authlog&quot; could be any alphanumeric string.  It is just used for reference.

# load: Default value is 1.
#       If set to 1 (true) then the log file will be reviewed.
#       This is just an easy way to keep configs in here but the script/module will not review or read the log file.
#       Chain creation will still happen, though.
logs_to_review[authlog][load]                                   = 1

# file: The &quot;file&quot; value is the location of the log file to review.
logs_to_review[authlog][file]                                   = /home/gardner/var/log/auth.log

# readentirefile:   Default value is global value of &quot;readentirefile&quot;
#                   Whether or not the entire log file is read each time.  If set to 0 (false), then we only read 
#                   from the end of the last read (or the beginning if it is the first read or if the log file has 
#                   been allegedly rotated)
#                   Reading from last read is faster, but if the log file is rotated AND the log file grows larger 
#                   than the last read, then we may miss some entries.
#                   For most situations, this should be left as the default of 0.
#                   If you rotate your log files frequently AND get a lot of traffic, then you may want to 
#                   set this to 1.
#                   Future enhancement: This should be enhanced to check the inode, file size, last change time, etc.  
#                   But for now, it is pretty dumb.
logs_to_review[authlog][readentirefile]         = 0

# libpath:  Default value is null.
#           This is an extra library path to require for modules for this log file (authlog).
#           This value is used with the next setting of &quot;module&quot;.
#           Future Enhancement:  Let this be a comma separated list and be an array
# logs_to_review[authlog][libpath]            = /home/gardner/git/ipblockerclassified/Net-IPBlocker/lib/

# module:   Default value is Net::IPBlocker::ReviewLogDefault
#           This is the module that is used to review the log file.
#           This can be a &quot;::&quot; separated path to the module.  For example, Net::IPBlocker::ApacheLogs.
#           This can also be a &quot;/&quot; separated path to the module.  For example, 
#               /home/johnboy/git/ipblockerclassified/Net-IPBlocker/lib/ApacheLogs.pm
#           This setting is expected to grow over time to accomodate different log files such as mail log, nginx/apache 
#           logs, ftp logs, etc.
#           Module Requirements:
#               The module must be a class and must have a function called &quot;new&quot; to instantiate (bless) the class.
#               The &quot;new&quot; function should be able to take a hash reference with the following keys:
#                   logobj:   This is all the configs associated with the log file along with the log contents.
#                   parentobjself: This is the object of the parent module.  This provides a lot of extra information.
#                   iptablesqueue_enqueue: This is a reference to the iptablesqueue_enqueue function.  This is used to
#                       add rules to the iptables queue to be ran.
#               There must be at least one function called &quot;grep_regexps&quot; that takes a logobject as a 
#               hash reference and returns a hash reference of IPs to block.  The IPs are a key and the value is 
#               whatever you want.
#               The module has access to the iptablesqueue_enqueue function and COULD set the queue directly and 
#               always returns an empty hash.
#               I do not reccomend setting the queue directly but it is possible.
#               Doing that will bypass multiple settings such as ports, protocols, directions, etc.
# logs_to_review[authlog][module] = Net::IPBlocker::ReviewLogSSH

# cycles: Default is global value of &quot;cycles&quot;
#   The number of times the log file will be reviewed.
#   Once this value hits 0, the log file will not be reviewed anymore.
# logs_to_review[authlog][cycles]                 = 10

# cyclesleep:   Default is global value of &quot;cyclesleep&quot;
#               The number of seconds to sleep between cycles.  Can be partial seconds.  So 0.5 is a half second.
logs_to_review[authlog][cyclesleep] = 1.5

# protocols:    Default is no protocol.
#               This is the protocol(s) that will be blocked in the firewall.
#               If the protocol is not set, then the default is no protocol.
#               You do not have to set protocol unless you set ports.
#               If you set ports but not protocol then the script will add the IP to the firewall but will not add 
#                the protocol and thus no ports.  So, the entire IP will be blocked.
#               There is no checking if the protocol is valid.  So if you set protocol=blah then the script will give 
#                an error when the rule tries to be added to the firewall.
#               Must be separated by non-alphanumeric-digit characters.  So tcp,udp is good.  tcp udp is good.  tcp-udp is good.
#                The &quot;_&quot; character is not allowed.  So tcp_udp is not good.
#                Most folks will use commas but whatever floats your boat.
logs_to_review[authlog][protocols] = tcp,udp

# ports:    Default is no ports
#           This is the port(s) that will be matched for blocking of IPs in the log file.
#           If the ports are not set, then the default is no ports.
#           This is nice if you want to block IPs that are trying to connect to, for example, ssh but not to HTTP
#           or HTTPS or etc etc.
#           You do not have to set ports but if you do, then you must set protocol.
#           Example:  ports=22,21,23 means that the script will block IPs that are trying to connect to 
#            ports 22, 21, and 23.
#           Must be separated by commas and ranges are accepted.  The iptables command has a maximum of 15 comma 
#           separated values.
#           Example 1:  logs_to_review[authlog][ports]                  = 22,21,23
#           Example 2:  logs_to_review[authlog][ports]                  = 22,21,23,1000:2000,3000:4000
#           Example 3:  logs_to_review[authlog][ports]                  = 22,21,23,1000:2000
#           Bad ports will log as an error and the rule will not be added.
#           If you set ports but no protocol then the entire IP will be blocked on the protocol.
logs_to_review[authlog][ports] = 22

# directions:   Default is source
#               This is the direction(s) that will be blocked in the firewall.
#                 If the direction is not set, then the default is source
#                Must be separated by non-digit-alphanumeric characters.  So source,destination is good.  source destination is good.
#                 source-destination is good.
#                 The &quot;_&quot; character is not allowed.  So source_destination is not good.
#                Most folks will use commas but whatever floats your boat.
#                Accepted values are source, destination, random
#               Example 1:  logs_to_review[authlog][direction]              = source,destination
#               Example 2:  logs_to_review[authlog][direction]              = source
#               Example 3:  logs_to_review[authlog][direction]              = destination
#               Example 4:  logs_to_review[authlog][direction]              = source,destination,cool,blah,blah,blah
#               In example 4, only source and destination will be used.  The values of cool,blah,blah,blah will be ignored.
#               I think most folks will not set this or just use &#39;source&#39; but I can see value in blocking the destination as well.
#               If you want to screw with hackers a bit, then set this to &#39;destination&#39; and then they will not get any response
#               The &quot;random&quot; value will ignore (for now) any other value set.  If random is used then source or 
#               destination will be randomly chosen for each IP rule.
#               logs_to_review[authlog][directions]          = source,destination
#               logs_to_review[authlog][directions]          = destination
logs_to_review[authlog][directions] = source
# logs_to_review[authlog][directions]          = random

# allowdeny:    Default value is global value of &quot;allowdeny&quot;
#               This is the order preference for whitelisted and blacklisted IPs.
#               If the order is set to &quot;Deny,Allow&quot; then blacklisted IPs will ALWAYS be 
#                 blocked (even if they are in the whitelisted hash)!
#               If the order is set to &quot;Allow,Deny&quot; then whitelisted IPs will ALWAYS be 
#                 allowed (even if they are in the blacklisted hash)!
#               If the order is not set or is set incorrectly then the default is &quot;Allow,Deny&quot;
#               When using authlog, I would reccomend setting the order to &quot;Allow,Deny&quot; so that whitelisted IPs are 
#                 always allowed for ssh.
#               The order is case insensitive.
logs_to_review[authlog][allowdeny]          = Allow,Deny

# allowlist:    List of IPs to allow just for this log file
logs_to_review[authlog][allowlist][01]     =  127.0.0.0/8
logs_to_review[authlog][allowlist][02]     =  23.116.91.65/29

# denylist:     List of IPs to block just for this log file
logs_to_review[authlog][denylist][01]      =  5.5.5.5
logs_to_review[authlog][denylist][02]      =  6.6.6.6

# regexpdeny:   Now comes the important part!  How to decide what to block?
#               Each regular expression must have a unique value.  
#               This is just typically indexed as 01, 02, 03, 04, etc.  But it can be any Alphanumeric
#               The index is sorted in simple Perl sort.  So 1, 10, 11 come before 2, 20, 21, etc.
#               Also, lowercase will come before uppercase.  So a, b, c, A, B, C.
#               The sorting may matter because the regular expressions are applied in order.
#               Regular expressions are case insensitive therefore &quot;Failed&quot; is the same as &quot;fAiLed&quot;
#               Regular expressions are Perl regular expressions so you can do fancy *.?[]{}() stuff.
logs_to_review[authlog][regexpdeny][01] = Failed password for root from
logs_to_review[authlog][regexpdeny][02] = Failed password for invalid user  
logs_to_review[authlog][regexpdeny][03] = Did not receive identification string from
logs_to_review[authlog][regexpdeny][04] = not allowed because listed in DenyUsers

# jailtime:     The default module is Net::IPBlocker::ReviewLogDefault which has a function post_enqueue().
#               This is called after IPs are enqueued to be blocked (aka, jailed).  
#               The default module will delete the IPs from the queue that have been jailed for
#               longer than 1800 seconds.  This is a good default but you can change it if you want.
#               Also, the entire ReviewLogDefault module can be overridden by setting the module key.
#               If you override the module then the post process function post_enqueue() will not be called (unless you
#               have one in your module).
#               Value is seconds.
logs_to_review[authlog][jailtime]            = 5

# # Authlog has a special value of allowed usernames
# logs_to_review[authlog][allowedusername][01]    = gardner
# logs_to_review[authlog][allowedusername][02]    = jiggerboy
# # Authlog has a special value of not-allowed usernames
# logs_to_review[authlog][deniedusername][01]       = root

## Now... an example without comments
# The maillog settings:
logs_to_review[maillog][load]                               = 0
logs_to_review[maillog][file]                               = /var/log/mail.log
logs_to_review[maillog][libpath]            = /home/gardner/git/ipblockerclassified/Net-IPBlocker/lib
logs_to_review[maillog][module]                 = Net::IPBlocker::ReviewLogDefault
logs_to_review[maillog][cycles]             = 10
logs_to_review[maillog][cyclesleep]         = 1.45
logs_to_review[maillog][order]              = Allow,Deny 
logs_to_review[maillog][regexpdeny][1]              = Relay access denied,Illegal address syntax from
logs_to_review[maillog][regexpdeny][2]              = SASL LOGIN authentication failed
logs_to_review[maillog][regexpdeny][3]              = SSL_accept error from
logs_to_review[maillog][regexpdeny][4]              = lost connection after AUTH from unknown
logs_to_review[maillog][regexpdeny][5]              = 503 5.5.1 Error: authentication
logs_to_review[maillog][regexpdeny][6]              = disconnect from.* commands=0\/0
logs_to_review[maillog][regexpdeny][7]              = non-SMTP command from unknown
logs_to_review[maillog][regexpdeny][8]              = connect to.*:25: Connection refused</code></pre>

<h1 id="Example-Script">Example Script</h1>

<pre><code>#!/usr/bin/perl -w

use strict;
use Net::IPBlocker;
use Log::Log4perl qw(get_logger);
use Data::Dumper;
use Getopt::ArgParse;

$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Indent   = 1;

my $logger = get_logger();    # This will change to the IPblocker object&#39;s logger when it is instantiated

main();

sub main {

    # Setup command line options
    my $clargs = setupArgParse();

    # Setup IPblocker object
    my $ipbArgs = {
        configsfile         =&gt; $clargs-&gt;configsfile,
        dumpconfigsandexit  =&gt; $clargs-&gt;dumpconfigsandexit,
        forceremovelockfile =&gt; $clargs-&gt;forceremovelockfile,
        # ignoreinterfaceips  =&gt; $clargs-&gt;ignoreinterfaceips,  # Not yet implemented
        iptables            =&gt; $clargs-&gt;iptables,
        lockfile            =&gt; $clargs-&gt;lockfile,
        log4perlconf        =&gt; $clargs-&gt;log4perlconf,
        loglevel            =&gt; $clargs-&gt;loglevel,
        prodmode            =&gt; $clargs-&gt;prodmode,
        queuechecktime      =&gt; $clargs-&gt;queuechecktime,
        readentirefile      =&gt; $clargs-&gt;readentirefile,
        cycles              =&gt; $clargs-&gt;cycles,
    };

    my $ipb    = IPblocker-&gt;new($ipbArgs);
    my $logger = $ipb-&gt;{logger} || get_logger();

    $logger-&gt;info(&quot;About to go!&quot;);

    # Start IPblocker object
    $ipb-&gt;go();
} ## end sub main

# Setup command line options
# This is often a lengthy subroutine so making it last is a probably good idea for readability
# The &quot;add_arg&quot; adds to a list so the order of the options for display is reverse order listed here.
# Meaning, if you want the help to display in a certain order, list them in reverse order here.
sub setupArgParse {
    my $args = shift;

    my $description = &quot;Blocks IPs based on regex used to get entry in a log file.  Command line options take &quot;;
    $description .= &quot;precedence over config file options.&quot;;
    $description .= &quot;\n\nThis is Perl so 0 (zero) is false and anything else is true.  &quot;;
    my $ap = Getopt::ArgParse-&gt;new_parser(
        prog        =&gt; &#39;IP Blocker&#39;,
        description =&gt; $description,
        epilog      =&gt; &#39;Copyright 2023.  Copyright notice at: https://www.gnu.org/licenses/gpl-3.0.txt&#39;,
    );

    my $helpreadentirefile = &quot;Read the entire file before processing.  Default is to not read the entire. &quot;;
    $helpreadentirefile .= &quot;This is a global setting and can be overridden per log file via a config file. &quot;;
    $helpreadentirefile .= &quot;No default is set here but will default to not reading the entire file. &quot;;
    $ap-&gt;add_arg(
        &#39;--readentirefile&#39;,
        type =&gt; &#39;Bool&#39;,
        dest =&gt; &#39;readentirefile&#39;,

        # default =&gt; 0,
        help =&gt; $helpreadentirefile,
    );

    my $helpqueuechecktime = &quot;When the queue is empty, how long to wait before checking again.  &quot;;
    $helpqueuechecktime .= &quot;When the queue is not empty, this value is ignored &quot;;
    $helpqueuechecktime .= &quot;and the queue is checked as fast as possible.  &quot;;
    $helpqueuechecktime .= &quot;This value is in seconds.  &quot;;
    $helpqueuechecktime .= &quot;It seems unnecessary to have this value configurable, but here it is.&quot;;
    $ap-&gt;add_arg(
        &#39;--queuechecktime&#39;,
        type    =&gt; &#39;Scalar&#39;,
        dest    =&gt; &#39;queuechecktime&#39;,
        # default =&gt; 3,
        help    =&gt; $helpqueuechecktime,
    );

    $ap-&gt;add_arg(
        &#39;--prodmode&#39;,
        type    =&gt; &#39;Scalar&#39;,
        dest    =&gt; &#39;prodmode&#39;,
        default =&gt; 0,
        help    =&gt; &#39;The production mode to use.  0 = test mode, 1 = production mode&#39;,
    );

    $ap-&gt;add_arg(
        &#39;--loglevel&#39;,
        choices =&gt; [qw(TRACE DEBUG INFO WARN ERROR FATAL)],
        dest    =&gt; &#39;loglevel&#39;,
        help    =&gt; &#39;The log level to use&#39;,
    );

    $ap-&gt;add_arg(
        &#39;--log4perlconf&#39;,
        type    =&gt; &#39;Scalar&#39;,
        dest    =&gt; &#39;log4perlconf&#39;,
        default =&gt; &#39;/etc/ipblocker/log4perl.conf&#39;,
        help    =&gt; &#39;The log4perl configuration file to use&#39;,
    );

    $ap-&gt;add_arg(
        &#39;--lockfile&#39;,
        type =&gt; &#39;Scalar&#39;,
        dest =&gt; &#39;lockfile&#39;,

        # default =&gt; &#39;/var/run/ipblocker.run.from.perlscript&#39;,
        # default =&gt; 0,
        help =&gt; &#39;The lock file location to use to prevent multiple instances from running&#39;,
    );

    $ap-&gt;add_arg(
        &#39;--iptables&#39;,
        type =&gt; &#39;Scalar&#39;,
        dest =&gt; &#39;iptables&#39;,

        # default =&gt; &#39;/sbin/iptables&#39;,
        help =&gt; &#39;The iptables command to use&#39;,
    );
    
    # $ap-&gt;add_arg(
    #     &#39;--ignoreinterfaceips&#39;,
    #     choices =&gt; [qw(0 1)],
    #     help    =&gt; &#39;Add IPs on the interfaces to allowlist.  Default is to add them (1).  Set to 0 to not add them.&#39;,
    # );

    my $help = &quot;Danger danger danger!  &quot;;
    $help .= &quot;This will force removal of lock file (if possible) before starting.  &quot;;
    $help .= &quot;Seriously, you better know what you are doing if you use this option.  &quot;;
    $help .= &quot;It will remove the lock file if it exists.  This is not advised unless you are sure the lock &quot;;
    $help .= &quot;file is stale.  You can potential have multiple ipblocker parent processes running at the &quot;;
    $help .= &quot;same time.  This will cause problems.  You have been warned. &quot;;
    $ap-&gt;add_arg(
        &#39;--forceremovelockfile&#39;,
        type    =&gt; &#39;Bool&#39;,
        dest    =&gt; &#39;forceremovelockfile&#39;,
        default =&gt; 0,
        help    =&gt; $help,
    );

    $ap-&gt;add_arg(
        &#39;--dumpconfigsandexit&#39;,
        type    =&gt; &#39;Bool&#39;,
        dest    =&gt; &#39;dumpconfigsandexit&#39;,
        default =&gt; 0,
        help    =&gt; &#39;Dump the configs and exit&#39;,
    );

    $ap-&gt;add_arg(
        &#39;--cycles&#39;,
        type =&gt; &#39;Scalar&#39;,
        dest =&gt; &#39;cycles&#39;,
        help =&gt; &#39;How many times to cycle through the queue before exiting.  Default is LONG_MAX (a large integer).&#39;,
    );

    $ap-&gt;add_arg(
        &#39;--configsfile&#39;,
        type =&gt; &#39;Scalar&#39;,

        # dest =&gt; &#39;configsfile&#39;,
        default =&gt; &#39;/etc/ipblocker/ipblocker.conf&#39;,
        help    =&gt; &#39;The configuration file to use&#39;,
    );

    return $ap-&gt;parse_args();
} ## end sub setupArgParse</code></pre>

<h1 id="Example-log-config">Example log config</h1>

<pre><code> There is no requirement to use Log4perl.  You can use any logging module you want compatible with Log::Any.
 
 This is just an example using log4perl which does a great job of handling threads.  
 Maybe other logging modules do as well. -\_O_/-

 I did testing only against log4perl so YMMV with other logging modules.

 Default location: /etc/ipblocker/log4perl.conf

 ###############################################################################
 #                              Log::Log4perl Conf                             #
 ###############################################################################
 # log4perl.rootLogger                                 = INFO, LOG1, Screen
 log4perl.rootLogger                                  = DEBUG, LOG1, Screen
 # log4perl.rootLogger                                  = INFO, LOG1
 # log4perl.rootLogger                                 = DEBUG, Syncer1, Screen
 # log4perl.rootLogger                                 = TRACE, LOG1, Screen
 # log4perl.appender.LOG1                              = Log::Log4perl::Appender::File
 log4perl.appender.LOG1                               = Log::Dispatch::FileRotate
 log4perl.appender.LOG1.size                          = 1024*1024*1024*1024
 log4perl.appender.LOG1.max                           = 40
 log4perl.appender.LOG1.DatePattern                   = yyyy-MM-dd
 log4perl.appender.LOG1.filename                      = /var/log/ipblocker/ipblocker.log
 # log4perl.appender.LOG1.filename                     = sub { my @now = localtime(); my $logfile = sprintf(&quot;/mnt/ramdrive/ipblocker/ipblocker_%04d%02d%02d.log&quot;, $now[5]+1900, $now[4]+1, $now[3] ); return $logfile }
 # log4perl.appender.LOG1.filename                     = sub { my @now = localtime(); my $logfile = sprintf(&quot;/home/gardner/var/log/ipblocker/ipblocker_%04d%02d%02d.log&quot;, $now[5]+1900, $now[4]+1, $now[3] ); return $logfile }
 # log4perl.appender.LOG1.mode                         = write
 log4perl.appender.LOG1.mode                          = append
 # log4perl.appender.LOG1.TZ                           = CST
 log4perl.appender.LOG1.layout                        = Log::Log4perl::Layout::PatternLayout
 # log4perl.appender.LOG1.layout.ConversionPattern      = %d|%p|%l|%m%n
 log4perl.appender.LOG1.layout.ConversionPattern      = %d|%p|%l|%X{TID}|%m{chomp}%n

 log4perl.appender.Screen                             = Log::Log4perl::Appender::Screen
 # log4perl.appender.Screen.mode                       = append
 log4perl.appender.Screen.layout                      = Log::Log4perl::Layout::PatternLayout
 log4perl.appender.Screen.layout.ConversionPattern    = %d|%p|%l|%X{TID}|%m{chomp}%n</code></pre>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Jeff Gardner, <code>&lt;jeffreygiraffe at cpan.org&gt;</code></p>

<h1 id="BUGS">BUGS</h1>

<p>Please report any bugs or feature requests to <code>bug-net-ipblocker at rt.cpan.org</code>, or through the web interface at <a href="https://rt.cpan.org/NoAuth/ReportBug.html?Queue=Net-IPBlocker">https://rt.cpan.org/NoAuth/ReportBug.html?Queue=Net-IPBlocker</a>. I will be notified, and then you&#39;ll automatically be notified of progress on your bug as I make changes.</p>

<h1 id="SUPPORT">SUPPORT</h1>

<p>You can find documentation for this module with the perldoc command.</p>

<pre><code>perldoc Net::IPBlocker</code></pre>

<p>You can also look for information at:</p>

<ul>

<li><p>RT: CPAN&#39;s request tracker (report bugs here)</p>

<p><a href="https://rt.cpan.org/NoAuth/Bugs.html?Dist=Net-IPBlocker">https://rt.cpan.org/NoAuth/Bugs.html?Dist=Net-IPBlocker</a></p>

</li>
<li><p>CPAN Ratings</p>

<p><a href="https://cpanratings.perl.org/d/Net-IPBlocker">https://cpanratings.perl.org/d/Net-IPBlocker</a></p>

</li>
<li><p>Search CPAN</p>

<p><a href="https://metacpan.org/release/Net-IPBlocker">https://metacpan.org/release/Net-IPBlocker</a></p>

</li>
</ul>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<h1 id="LICENSE-AND-COPYRIGHT">LICENSE AND COPYRIGHT</h1>

<p>This software is Copyright (c) 2024 by Jeff Gardner.</p>

<p>This is free software, licensed under:</p>

<pre><code>The Artistic License 2.0 (GPL Compatible)</code></pre>


</body>

</html>


